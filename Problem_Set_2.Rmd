---
title: "Problem_Set_2"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(faux)
library(ivreg)
library(ggplot2)
```

## Theory
Show that, without perfect compliance, the Intention-to-treat effect will be smaller than the

ITT and ATE are two methods used to estimate the impact of a treatment. 


Without perfect compliance outcomes are not homogeneous. To account for heterogeneous outcomes we can delineate our binary treatment indicator ($D_i$) by those who are and are not affected by the binary instrument ($Z_i$):

* $D_1i$ when $Z_i= 1$
* $D_0i$ when $Z_i= 0$

$i$ represents the treatment status ($D_i$) when the instrument ($Z_i$) takes one of the two binary values.

We can represent the observed treatment status in the switching equation:

$$D_i=D_{0i}+(D_{1i}-D_{0i})Z_i\ (Equation \ 1)$$ 
When $Z_i=1$, $D_i$ takes on the value $D_{1i}$, as the $D_{0i}$ cancel. When $Z_i=0$, $D_i$ takes on the value $D_{0i}$, the second terms disappears, leaving $D_{0i}$. 

We can rewrite this equation in regression form as:

$$\delta_{0}+\delta_{1i}Z_i+\eta_i$$

However $\delta_{1i}$ is not uniform for all individuals in the sample. Those who have a high $\delta$ are encouraged or discouraged by $Z_i$. But those with a low $\delta$ are less affected by $Z_i$. 

There population can be divided into four groups. Those who are unaffected by the instrument ($Z_i$):

* Always-Takers: People who always take the treatment. $D_{1i}=D_{0i}=1$.
* Never-Takers: People who never take the Treatment. $D_{1i}=D_{0i}=0$.

Additionally, there are those who are affected by the instrument. 
* Compliers: Those influenced by the instrument ($Z_i$) as expected. $D_{1i}=1\ and\ D_{0i}=0$.
* Defiers: Those influenced by the instrument ($Z_i$) unexpectedly. $D_{1i}=0\ and\ D_{0i}=1$.


## Simulation Excercise

You can include R code in the document as follows:

```{r Generate Data, echo=FALSE}

## Base setup

  # Base Data
set.seed(1000) #sample
obs = 100000 # observations

  # Initial Parameters
beta = 1 # Stated Beta
alpha = 0 # Stated alpha
delta_zero =0 #Stated delta_zero
u = rnorm(n=obs,) # random sample

  #Generate correlated variables x, epsilon and z
toy_dfa = rnorm_multi(n = obs,
                     r=c(1,0.4,0.5, #  x correlated with epsilon 40%. z correlated with z 50%
                         0.4,1,0, #x correlated with epsilon 40%. e correlated with z 0%
                         0.5,0,1), # x correlated with epsilon 50%. epsilon correlated with z 0%
                     varnames=c("x","epsilon","z"))

  # Combine generate variables into dataframe
toy_dfa = data.frame(toy_dfa, u, alpha, beta, delta_zero)

  # Create Y variable
toy_dfa = toy_dfa %>% mutate(y=alpha+z+u) #back out y from known variables

  # Check correlations
cor.test(toy_dfa$x,toy_dfa$e) #approx 40%
cor.test(toy_dfa$z,toy_dfa$e) #approx 0%
cor.test(toy_dfa$x,toy_dfa$z) #approx 50%

  # Test Regression
test_reg = lm(y ~ x, data = toy_dfa)
summary(test_reg) 

# alpha is not zero, but is not statistically significant. Fair to assume it is noise due to sample size. 


```


```{r Generate Beta, echo=FALSE}

# Define sample sizes ans simulations
samples <- c(50, 100, 250, 1000)
simulations = numeric(1000)

for (i in 1:length(sample_size)) {
  size <- sizes[i]
  
  for (j in 1:simulations) {
    sample_index <- sample(1:obs, samples, replace = FALSE)
    sample_data <- toy_dataset[sample_index, ]
    
    # OLS
    fit_ols <- lm(y ~ x, data = sample_data)
    betas_ols[j] <- coef(fit_ols)["x"]
    
    # IV
    fit_iv <- ivreg(y ~ x | z, data = sample_data)
    betas_iv[j] <- coef(fit_iv)["x"]
  }
  
  # Convert the vectors to a data frame
  betas_df <- data.frame(method = c(rep("OLS", length(betas_ols)), 
                                    rep("IV", length(betas_iv))),
                         beta = c(betas_ols, betas_iv),
                          sample_size = c(sample_sizes, sample_sizes))

}


ggplot(betas_df, aes(x=beta, color=method)) +
  geom_density()+
  facet_wrap(~sample_size, scales="free")


```

## Empirical Application

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
